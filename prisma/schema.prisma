generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// EXISTENTE (não mexer)
model Cpu {
  id         String   @id @default(cuid())
  name       String   @unique
  slug       String   @unique
  brand      String
  cores      Int
  threads    Int
  baseClock  Float
  boostClock Float?
  socket     String
  
  // ✅ NOVOS CAMPOS PARA FILTROS
  hasIntegratedGraphics Boolean @default(false)
  tdp                   Int?    // TDP em Watts
  
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  offers         Offer[]
  priceSnapshots PriceSnapshot[]
  alerts         PriceAlert[]
}

// EXISTENTE (não mexer)
model Store {
  id        String   @id @default(cuid())
  name      String   @unique
  url       String
  createdAt DateTime @default(now())

  offers                Offer[]
  priceSnapshots        PriceSnapshot[]
  productOffers         ProductOffer[]
  productPriceSnapshots ProductPriceSnapshot[]
}

// EXISTENTE (não mexer, mas vamos expandir para Product)
model Offer {
  id         String   @id @default(cuid())
  cpuId      String
  storeId    String
  priceCents Int
  url        String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  cpu   Cpu   @relation(fields: [cpuId], references: [id])
  store Store @relation(fields: [storeId], references: [id])
}

// EXISTENTE (não mexer)
model PriceSnapshot {
  id         String   @id @default(cuid())
  cpuId      String
  storeId    String
  priceCents Int
  date       DateTime
  createdAt  DateTime @default(now())

  cpu   Cpu   @relation(fields: [cpuId], references: [id])
  store Store @relation(fields: [storeId], references: [id])

  @@unique([cpuId, storeId, date])
}

// EXISTENTE (não mexer)
model User {
  id           String   @id @default(cuid())
  email        String   @unique
  username     String?  @unique
  passwordHash String?
  name         String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  alerts    PriceAlert[]
  accounts  Account[]
  sessions  Session[]
  favorites Favorite[]
}

// EXISTENTE (não mexer)
model PriceAlert {
  id               String    @id @default(cuid())
  userId           String
  cpuId            String
  targetPriceCents Int
  isActive         Boolean   @default(true)
  triggeredAt      DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  user   User              @relation(fields: [userId], references: [id])
  cpu    Cpu               @relation(fields: [cpuId], references: [id])
  events PriceAlertEvent[]

  @@unique([userId, cpuId, targetPriceCents])
  @@index([cpuId, isActive])
}

// EXISTENTE (não mexer)
model PriceAlertEvent {
  id         String   @id @default(cuid())
  alertId    String
  priceCents Int
  storeName  String?
  createdAt  DateTime @default(now())

  alert PriceAlert @relation(fields: [alertId], references: [id])

  @@index([alertId, createdAt])
}

// EXISTENTE (não mexer)
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

// EXISTENTE (não mexer)
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// EXISTENTE (não mexer)
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// EXISTENTE (expandir enum depois)
enum FavoriteItemType {
  CPU
  GPU
  MOTHERBOARD
}

// EXISTENTE (não mexer)
model Favorite {
  id        String           @id @default(cuid())
  userId    String
  itemType  FavoriteItemType
  itemId    String
  createdAt DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, itemType, itemId])
  @@index([userId, itemType])
}

// NOVO: Produto genérico (para novas categorias)
enum ProductType {
  GPU
  MOTHERBOARD
}

model Product {
  id        String      @id @default(cuid())
  type      ProductType
  name      String
  slug      String      @unique
  brand     String
  specsJson Json // Specs específicas (ex.: { chipset: "B450", socket: "AM4" })
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  offers         ProductOffer[]
  priceSnapshots ProductPriceSnapshot[]
  gpu            Gpu?
  motherboard    Motherboard?

  @@unique([type, name])
  @@index([type, brand])
}

// NOVO: Oferta para produtos genéricos
model ProductOffer {
  id           String   @id @default(cuid())
  productId    String
  storeId      String
  priceCents   Int
  url          String
  affiliateUrl String? // NOVO: URL com afiliação
  stockStatus  String   @default("available") // available, out_of_stock, discontinued
  lastSeenAt   DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  product Product @relation(fields: [productId], references: [id])
  store   Store   @relation(fields: [storeId], references: [id])
}

// NOVO: Histórico de preço para produtos genéricos
model ProductPriceSnapshot {
  id         String   @id @default(cuid())
  productId  String
  storeId    String
  priceCents Int
  date       DateTime
  createdAt  DateTime @default(now())

  product Product @relation(fields: [productId], references: [id])
  store   Store   @relation(fields: [storeId], references: [id])

  @@unique([productId, storeId, date])
}

model Gpu {
  id         String   @id @default(cuid())
  productId  String   @unique
  vramGb     Int
  vramType   String   // GDDR6, GDDR5X, etc.
  baseClock  Int      // MHz
  boostClock Int?     // MHz
  tdp        Int      // Watts
  interface  String   // PCIe 4.0 x16, etc.
  
  // ✅ NOVO CAMPO PARA FILTROS
  chipset    String?  // Ex: "RTX 4060", "RX 7600 XT"
  
  createdAt  DateTime @default(now())

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model Motherboard {
  id         String   @id @default(cuid())
  productId  String   @unique
  chipset    String   // B450, Z590, etc.
  socket     String   // AM4, LGA1200, etc.
  formFactor String   // ATX, Micro-ATX, Mini-ITX
  ramSlots   Int
  ramType    String   // DDR4, DDR5
  maxRamGb   Int
  
  maxRamSpeed Int?    // MHz (ex: 3200, 5600)
  wifi        Boolean @default(false)
  
  sataPorts  Int
  m2Slots    Int
  usbPorts   Json     // { usb3: 4, usb2: 2 }
  createdAt  DateTime @default(now())

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
}